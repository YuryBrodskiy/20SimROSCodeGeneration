/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%Model
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "%SUBMODEL_NAME%Model.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>

using namespace std;

namespace %MODEL_NAME%
{

	%SUBMODEL_NAME%Model::%SUBMODEL_NAME%Model(): m_model_config(this)
	{
		using namespace boost;

		setupComputation();
	}

	%SUBMODEL_NAME%Model::~%SUBMODEL_NAME%Model(void)
	{
		/* free memory */
		delete[] %VARPREFIX%%XX_CONSTANT_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_PARAMETER_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_INITIAL_VALUE_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_VARIABLE_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_STATE_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_RATE_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_MATRIX_ARRAY_NAME%;
		delete[] %VARPREFIX%%XX_UNNAMED_ARRAY_NAME%;
		delete[] %VARPREFIX%workarray;
	}

  void %SUBMODEL_NAME%Model::setupComputation()
  {
    %VARPREFIX%start_time = %START_TIME%;
    %VARPREFIX%finish_time = 0;
    %VARPREFIX%step_size = %TIME_STEP_SIZE%;
    %VARPREFIX%%XX_TIME% = 0;
    %VARPREFIX%major = true;

    %VARPREFIX%number_constants = %NUMBER_CONSTANTS%;
    %VARPREFIX%number_parameters = %NUMBER_PARAMETERS%;
    %VARPREFIX%number_initialvalues = %NUMBER_INITIAL_VALUES%;
    %VARPREFIX%number_variables = %NUMBER_VARIABLES%;
    %VARPREFIX%number_states = %NUMBER_STATES%;
    %VARPREFIX%number_rates = %NUMBER_STATES%;
    %VARPREFIX%number_matrices = %NUMBER_MATRICES%;
    %VARPREFIX%number_unnamed = %NUMBER_UNNAMED%;

    /* the variable arrays */
    %VARPREFIX%%XX_CONSTANT_ARRAY_NAME% = new XXDouble[%NUMBER_CONSTANTS% + 1]; /* constants */
    %VARPREFIX%%XX_PARAMETER_ARRAY_NAME% = new XXDouble[%NUMBER_PARAMETERS% + 1]; /* parameters, currently only one type of parameter exists: double */
    %VARPREFIX%%XX_INITIAL_VALUE_ARRAY_NAME% = new XXDouble[%NUMBER_INITIAL_VALUES% + 1]; /* initial values */
    %VARPREFIX%%XX_VARIABLE_ARRAY_NAME% = new XXDouble[%NUMBER_VARIABLES% + 1]; /* variables */

    %VARPREFIX%%XX_STATE_ARRAY_NAME% = new XXDouble[%NUMBER_STATES% + 1]; /* states */
    %VARPREFIX%%XX_RATE_ARRAY_NAME% = new XXDouble[%NUMBER_STATES% + 1]; /* rates (or new states) */
    %VARPREFIX%%XX_MATRIX_ARRAY_NAME% = new XXMatrix[%NUMBER_MATRICES% + 1]; /* matrices */
    %VARPREFIX%%XX_UNNAMED_ARRAY_NAME% = new XXDouble[%NUMBER_UNNAMED% + 1]; /* unnamed */
    %VARPREFIX%workarray = new XXDouble[%WORK_ARRAY_SIZE% + 1];
  }

	bool %SUBMODEL_NAME%Model::loadModelConfiguration(std::string uri)
	{
	  m_model_config.load(uri);
	  return true;
	}

	XXModelConfiguration& %SUBMODEL_NAME%Model::getModelConfiguration()
	{
	  return m_model_config;
	}

  bool %SUBMODEL_NAME%Model::configure()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    %VARPREFIX%initialize = true;
    //CONSTANTS
    %INITIALIZE_CONSTANTS%

    //PARAMETERS
    %INITIALIZE_PARAMETERS%

    //INITIAL VALUES
    %INITIALIZE_INITIAL_VALUES%

    //MATRICES
    %INITIALIZE_MATRICES%

    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    // overload INITIALIZE_* with values from xml
    std::vector<XVMatrix>& pps = m_model_config.getConfiguration();

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      if( static_cast<unsigned int>(pps[i].storage.rows * pps[i].storage.columns) != pps[i].values.size())
        throw std::out_of_range("" + pps[i].name);

      // Copy to XXData -> double*
      memcpy(pps[i].storage.mat, pps[i].values.data(), pps[i].values.size()*sizeof(double));
    }

    //STATES - do NOT move this line up!
    %INITIALIZE_STATES%

    /* end of initialization phase */
    %VARPREFIX%initialize = false;
    return %VARPREFIX%initialize;
  }

  void %SUBMODEL_NAME%Model::start()
  {
    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void %SUBMODEL_NAME%Model::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
         and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void %SUBMODEL_NAME%Model::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  XXDouble %SUBMODEL_NAME%Model::getTime(void)
  {
    return %VARPREFIX%%XX_TIME%;
  }

	/* This function calculates the initial equations of the model.
	 * These equations are calculated before anything else
	 */
	inline void %SUBMODEL_NAME%Model::CalculateInitial (void)
	{
		%INITIAL_EQUATIONS%
	}

	/* This function calculates the static equations of the model.
	 * These equations are only dependent from parameters and constants
	 */
	inline void %SUBMODEL_NAME%Model::CalculateStatic (void)
	{
		%STATIC_EQUATIONS%
	}

	/* This function calculates the input equations of the model.
	 * These equations are dynamic equations that must not change
	 * in calls from the integration method (like random and delay).
	 */
	inline void %SUBMODEL_NAME%Model::CalculateInput (void)
	{
		%INPUT_EQUATIONS%
	}

	/* This function calculates the dynamic equations of the model.
	 * These equations are called from the integration method
	 * to calculate the new model rates (that are then integrated).
	 */
	inline void %SUBMODEL_NAME%Model::CalculateDynamic (void)
	{
		%DYNAMIC_EQUATIONS%
	}

	/* This function calculates the output equations of the model.
	 * These equations are not needed for calculation of the rates
	 * and are kept separate to make the dynamic set of equations smaller.
	 * These dynamic equations are called often more than one time for each
	 * integration step that is taken. This makes model computation much faster.
	 */
	inline void %SUBMODEL_NAME%Model::CalculateOutput (void)
	{
		%OUTPUT_EQUATIONS%
		%IF%%XX_NR_DELAY_FUNCS%
		/* delay update */
		XXDelayUpdate();
		%ENDIF%
	}

	/* This function calculates the final equations of the model.
	 * These equations are calculated after all the calculations
	 * are performed
	 */
	inline void %SUBMODEL_NAME%Model::CalculateFinal (void)
	{
		%FINAL_EQUATIONS%
	}

	bool %SUBMODEL_NAME%Model::setPeriod(double seconds)
	{
			%VARPREFIX%step_size = seconds;
			return true;
	}

	double %SUBMODEL_NAME%Model::getPeriod()
  {
      return %VARPREFIX%step_size;
  }

}
