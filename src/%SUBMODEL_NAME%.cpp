/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "%SUBMODEL_NAME%.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>
#include <ros/package.h>
#include <ros/ros.h>
#include <std_msgs/String.h>

using namespace std;

namespace %MODEL_NAME%
{
	%SUBMODEL_NAME%::%SUBMODEL_NAME%(string name): %SUBMODEL_NAME%Model(), m_loop_rate(0.0)
	{
		using namespace boost;

    try
    {
      m_config_file = ros::package::getPath("%SUBMODEL_NAME%");
      m_config_file = m_config_file + "/config/%SUBMODEL_NAME%_config.xxsim";

      %SUBMODEL_NAME%Model::loadModelConfiguration(m_config_file);
      ROS_INFO("Loaded XXModelConfiguration");
    }
    catch(std::exception& e)
    {
      ROS_ERROR("%s", e.what());
      throw(e);
    }

    %SUBMODEL_NAME%Model::configure();

		setupComponentInterface();
	}

	%SUBMODEL_NAME%::~%SUBMODEL_NAME%(void)
	{ }

	/* the initialization function for submodel */
	void %SUBMODEL_NAME%::start()
	{
	  double frequency = 1.0 / getPeriod();
	  m_loop_rate = ros::Rate(frequency);

	  ROS_INFO("ros::Rate::expectedCycleTime = %.4lf", m_loop_rate.expectedCycleTime().toSec());

//	  // ???
//		for(unsigned int i = 0; i < inputPorts.size(); ++i)
//		{
//		  if(!inputPorts[i].getPort()->connected() )
//      {
//        log(Warning) << "InputPort (" << inputPorts[i].getFullName() << ") not connected." << endlog();
//      }
//		}
//
//    // getNumSubscribers ()
//    for(unsigned int i = 0; i < outputPorts.size(); ++i)
//    {
//      if(!outputPorts[i].getPort()->connected() )
//      {
//        log(Warning) << "OutputPort (" << outputPorts[i].getFullName() << ") not connected." << endlog();
//      }
//      outputPorts[i].getPort()->setDataSample( outputPorts[i].getPortData() );
//    }

	  ros::spinOnce(); //process callbacks
    %SUBMODEL_NAME%Model::start();

#ifdef COMPUTATION_TIME_MEASUREMENT
    m_cum_avg = 0;
    m_cum_avg_counter = 0;
#endif
	}

	/* the function that calculates the submodel */
	void %SUBMODEL_NAME%::run()
	{

	  while(ros::ok())
    {
//#ifdef COMPUTATION_TIME_MEASUREMENT
//		using namespace RTT::os;
//    TimeService::ticks timestamp = TimeService::Instance()->getTicks();
//#endif

	    ros::spinOnce(); //Calls all queued callbacks and therefore gets the input signals
	    %SUBMODEL_NAME%Model::step();

//#ifdef COMPUTATION_TIME_MEASUREMENT
//		Seconds elapsed = TimeService::Instance()->secondsSince( timestamp );
//    m_cum_avg = m_cum_avg + (elapsed - m_cum_avg) / (++m_cum_avg_counter);
//#endif
	    m_loop_rate.sleep();
    }
	}

	/* the termination function for submodel */
	void %SUBMODEL_NAME%::stop()
	{
#ifdef COMPUTATION_TIME_MEASUREMENT
		log(Info) << "Cumulative average computation time: " << m_cum_avg << endlog();
#endif

		ros::spinOnce(); //process callbacks
		%SUBMODEL_NAME%Model::stop();
	}

	/* this PRIVATE function sets the input variables from the input vector */
	//@todo Improve for multiple component inputs to have a synchronized execution.
	void %SUBMODEL_NAME%::CopyInputsToVariables ()
	{
		/* ROS Entry to copy port to input array */
    for (vector<Adapter20Sim<ros::Subscriber>* >::iterator it =
				m_input_ports.begin(); it != m_input_ports.end(); ++it)
	  {
      // Reading is done implicitly -> callback in Adapter20Sim
			(*it)->copyPortToVariable();
	  }
	}

	/* this PRIVATE function uses the output variables to fill the output vector */
	void %SUBMODEL_NAME%::CopyVariablesToOutputs ()
	{
		/* OROCOS Entry to copy output to port */
	  for (vector<Adapter20Sim<ros::Publisher>* >::iterator it =
				m_output_ports.begin(); it != m_output_ports.end(); ++it)
	  {
	    Adapter20Sim<ros::Publisher>* pub = *it;
			pub->copyVariableToPort();
			pub->getPort()->publish(pub->getPortData());
	  }
	}

	bool %SUBMODEL_NAME%::setPeriod(double period)
	{
	  double frequency = 1.0 / period;
	  m_loop_rate = ros::Rate(frequency);
	  %SUBMODEL_NAME%::setPeriod(period);
	  return true;
	}

  void %SUBMODEL_NAME%::setupComponentInterface()
  {
//    this->addProperty("integration_step_size", %VARPREFIX%step_size ).doc("Integration step size.");
//    this->addProperty("configuration_file", m_config_file).doc("Path to configuation xml, relative to run directory");

    std::vector<XVMatrix>& pps = %SUBMODEL_NAME%Model::getModelConfiguration().getConfiguration();
    ROS_INFO("Number of ports and properties in XML: %lu", pps.size());

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      ROS_DEBUG("Name: %s CEType: %d Storage: %p Rows: %i Columns: %i", pps[i].name.c_str(), pps[i].type, pps[i].storage.mat, pps[i].storage.rows, pps[i].storage.columns);

      switch(pps[i].type)
      {
        case(INPUT):
        {
          std::string topic("%SUBMODEL_NAME%/");
          topic.append(replaceIllegalCharacter(pps[i].name));
          Adapter20Sim<ros::Subscriber>* xxsim = new Adapter20Sim<ros::Subscriber>(pps[i], topic);
          ros::Subscriber sub = m_node_handle.subscribe(topic, 1, &Adapter20Sim<ros::Subscriber>::subscribe_callback, xxsim);
          if(!sub)
          {
            ROS_ERROR("Could not subscribe to topic: %s", topic.c_str());
            break;
          }
          xxsim->setPort(new ros::Subscriber(sub));
          m_input_ports.push_back(xxsim);
          break;
        }
        case(OUTPUT):
        {
          std::string topic("%SUBMODEL_NAME%/");
          topic.append(replaceIllegalCharacter(pps[i].name));
          Adapter20Sim<ros::Publisher >* xxsim = new Adapter20Sim<ros::Publisher>(pps[i], topic);
          ros::Publisher pub = m_node_handle.advertise<flat_matrix_t>(topic, 1);
          if(!pub)
          {
            ROS_ERROR("Could not advertise the topic: %s", topic.c_str());
            break;
          }
          xxsim->setPort(new ros::Publisher(pub));
          m_output_ports.push_back(xxsim);
          break;
        }
//        case(PARAMETER):
//        {
//          RTT::PropertyBag* p_bag = createPropertyBags(pps[i].name, NULL); // Create the sub-model hierarchy
//          Property<RTT::types::carray<double> >* prop = new Property<RTT::types::carray<double> >(makeShortName(pps[i].name), pps[i].description,
//              RTT::types::carray<double>(pps[i].storage.mat, static_cast<std::size_t>(pps[i].storage.rows * pps[i].storage.columns)));
//          Adapter20Sim<RTT::Property<RTT::types::carray<double> > > xxsim(pps[i], prop);
//          p_bag->addProperty(*prop);
//          propertyPorts.push_back(xxsim);
//          break;
//        }
        default:
        {
          break;
        }
      }
    }
    ROS_INFO("Total input ports: %lu", m_input_ports.size());
    ROS_INFO("Total output ports: %lu", m_output_ports.size());
//    ROS_INFO("Total properties: %d", propertyPorts.size());
  }

  double %SUBMODEL_NAME%::getTime()
  {
    return %SUBMODEL_NAME%Model::getTime();
  }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "%SUBMODEL_NAME%");

  try
  {
    %MODEL_NAME%::%SUBMODEL_NAME% model;
    model.start();
    model.run();
    model.stop();
  }
  catch(std::exception& e)
  {
    ROS_ERROR("%s", e.what());
    return -1;
  }

  ROS_INFO("%SUBMODEL_NAME% stopped.");
  return 0;
}

